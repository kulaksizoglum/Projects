import math


def egcd(a, b):
    x,y, u,v = 0,1, 1,0
    while a != 0:
        q, r = b//a, b%a
        m, n = x-u*q, y-v*q
        b,a, x,y, u,v = a,r, u,v, m,n
    gcd = b
    return gcd, x, y





def exhaustiveSearchFORNEAR(clength):
    i=2
    print("start")
    while(True):
        i=pow(i,2)
        m=int(pow(i,17))
        #print(m.bit_length())
        if m.bit_length()>clength-1:
            print(i)
            print("found")
            return i





          
def modinv(a, m):
    gcd, x, y = egcd(a, m)
    if gcd != 1:
        return None  # modular inverse does not exist
    else:
        return x % m

     

N=223657859766144023323975120751246308270349624748349675083769925918789503497614662489968136287903240217419676450361429694421871511843957700970218235759498443614833318092931765347216940713346359968279518075329167958736296554543728635246138929251208780446675567130891872562776204008809426744921549194636590770886569555683650739468010411364550491542546940933866887184619665711809176911780017788816413701783562918995081107754493978733423077508595483272157611316044452999143965819419393572255940680247015630197744660345688449332998584779977544358316597576994314986322332284580410046513600329892486466122703108374316422340853237281774848941313615836814255556001566072175623973493297591294335349087569608056610363043910893458345092338381543490221334770032663361883671534398098882433949895440210549331384333277774764351905291047781299766526170463628876778618958164326823358274018787059445837822057410844815063905590860537356561403112538712892513533291695973630089947988527886333991113450500436998781726635149401000636540614535711159426410828179415759829439555704024037537581914384936163614528568408354867945705797051822184792492201328224287780593750785159051684333959337532784243000317069606887606879743761821403309677083277828514944243054119009100504712199688593975568221513306723156884000232757133854756366733757054184608998328313717933467071821982792447353268586164279487350411883253182834403020157749998291522583229632804933569509872827094895016940943886412321094069042912067184654291452447271607123349511488171094538895510670786955199302820201321743157070080878114102864183670021712195435285194571462114237112888085525992406273676251618510314762959113098403437875872000055298048764042889369624300372225884514937430682034343177958576845782233807323094648626557124126068982812259989930154181097276945937691473338458843754568465651538508758073358475193235333360969753981531742672692864738198795013133171504460182017682578291909277355683737362686615312733563660679559873862037089763914089959724933586052283906838946927568255053893267264726932678582874115099708992772447131436436750259312237623566898287206469193225558524686538792360673104755313300203837226598476214001721836367864196351049976579073142410364805784053538650225549854865750643064621327416352560706853970343251184429212854679
C= 10996907317744048201180239191184801878870026359954251163808786991823988392040721694956774540613511870672915186967674497345695382645430111824083800355570536408550748237322495556640595897950904266978255920300494206063326443644038077060867859678853573135463689576016437189518186799433888575401030210875676845244656583911134078393876421877639911657047543070395464987842170462799343767525393215191609774073190285806734017390270810257697704746005511384590358282243168705497528675364827201498077988713907302696070779021284913585400756722751893643306497629378643206323310558189248071831717808359955530448986481886749316175356424375727873597173466277727860357595136
e = 17

print(f"N is {N.bit_length()} bit long")
print(f"M is 129 bit long")
print(f"Max bit length that M^e can generate is (lets even say M= 2**129) (2**129)17 = 2^2193, 2192 is the above maximum bit) of M^e can generate ")
print("modulo of N is completely unnecessary we can try to find M ^e values that equals exactly to C")



len= C.bit_length()
print(len)


m=exhaustiveSearchFORNEAR(len)
print("message int representation,",m)
if(pow(m,e)==C):
    print("m^e equals C, no need for more research m is found")
print("\n\n")
print(m)
print("\n")
print ("\n\nMessage: ", m.to_bytes((m.bit_length()+7)//8, byteorder='big'))
byte_representation = m.to_bytes((m.bit_length() +7) // 8, byteorder='big')
string_representation = byte_representation.decode('utf-8')
print(string_representation)







